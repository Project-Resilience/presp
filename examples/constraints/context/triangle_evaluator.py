import numpy as np
import torch

from presp.evaluator import Evaluator
from presp.prescriptor import NNPrescriptor


class TriangleEvaluator(Evaluator):
    def __init__(self, device: str = "cpu", n_jobs: int = 1):
        super().__init__(["f1", "f2"], n_jobs=n_jobs)
        self.device = device

        contexts = []
        for i in range(10):
            for j in range(10):
                context = [i, i+1, j, j+1]
                contexts.append(context)
        contexts = torch.tensor(contexts, dtype=torch.float32, device=device)

        generator = torch.Generator(device=self.device)
        generator.manual_seed(42)
        train_idxs = torch.randperm(contexts.shape[0], device=self.device, generator=generator)[:80]

        self.contexts = contexts[train_idxs]
        self.test_set = contexts[~train_idxs]

    def update_predictor(self, _):
        pass

    def get_optimal_actions(self, test: bool = False) -> torch.Tensor:
        """
        Returns the optimal actions for each context.
        returns X: c x a x L where L is the number of points we want to use to plot.
        """
        X = []
        contexts = self.contexts if not test else self.test_set
        for c in contexts:
            x1min, x1max, x2min, x2max = c
            x1 = torch.linspace(x1min, x1max, steps=10, device=self.device)
            x2 = x1min + x2max - x1
            x = torch.stack([x1, x2], dim=0)
            X.append(x)

        X = torch.stack(X, dim=0)
        return X

    # pylint: disable=invalid-name
    def f1(self, X: torch.Tensor) -> float:
        """
        Minimize x1
        """
        return X[:, 0].unsqueeze(1)

    def f2(self, X: torch.Tensor) -> float:
        """
        Minimize x2
        """
        return X[:, 1].unsqueeze(1)

    def g1(self, X: torch.Tensor) -> torch.Tensor:
        """
        X: 3x2 -> 3x1
        Constraint that forces x1 and x2 to be above the diagonal line of the square.
        x2 >= c[3] - x1 + c[0]: diagonal line from the top left to bottom right
        So c[0] + c[3] - x1 - x2 <= 0
        """
        return (self.contexts[:, 0] + self.contexts[:, 3] - X[:, 0] - X[:, 1]).unsqueeze(1)

    def g2(self, X: torch.Tensor) -> torch.Tensor:
        """
        Constraint forcing x1 to be within the bounds specified by the context
        x1 >= c[0]
        c[0] - x1 <= 0
        """
        return (self.contexts[:, 0] - X[:, 0]).unsqueeze(1)

    def g3(self, X: torch.Tensor) -> torch.Tensor:
        """
        Constraint forcing x2 to be greater than 0
        """
        return (X[:, 0] - self.contexts[:, 1]).unsqueeze(1)

    def g4(self, X: torch.Tensor) -> torch.Tensor:
        return (self.contexts[:, 2] - X[:, 1]).unsqueeze(1)

    def g5(self, X: torch.Tensor) -> torch.Tensor:
        return (X[:, 1] - self.contexts[:, 3]).unsqueeze(1)

    def prescribe(self, candidate: NNPrescriptor, test: bool = False) -> torch.Tensor:
        """
        Returns the solutions generated by the candidate prescriptor.
        """
        with torch.no_grad():
            context = self.contexts if not test else self.test_set
            X = candidate.forward(context) if not test else candidate.forward(context)

            # Hard constraint: scale to the context
            # X = torch.sigmoid(X)
            # X[:, 0] = X[:, 0] * (context[:, 1] - context[:, 0]) + context[:, 0]
            # X[:, 1] = X[:, 1] * (context[:, 3] - context[:, 2]) + context[:, 2]

        return X

    def compute_outcomes(self, actions: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        """
        Computs individual outcomes for each set of actions.
        actions: c x a
        outcomes: c x o, c x g
        Where C is the number of contexts, a is the number of actions, o is the number of outcomes, and g is the number
        of constraints.
        """
        f1 = self.f1(actions)
        f2 = self.f2(actions)
        F = torch.cat([f1, f2], dim=1)

        g1 = self.g1(actions)
        g2 = self.g2(actions)
        g3 = self.g3(actions)
        g4 = self.g4(actions)
        g5 = self.g5(actions)
        G = torch.cat([g1, g2, g3, g4, g5], dim=1)

        return F, G

    def evaluate_candidate(self, candidate: NNPrescriptor) -> tuple[np.ndarray, float]:
        with torch.no_grad():
            actions = self.prescribe(candidate)
            F, G = self.compute_outcomes(actions)

            f = F.mean(dim=0).cpu().numpy()
            g = torch.where(G > 0, G, 0).sum(dim=1).mean().item()

            # constraint as penalty
            lamb = 0.01
            f = f + lamb * g

        # return f, g
        return f, 0
