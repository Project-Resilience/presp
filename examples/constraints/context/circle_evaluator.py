import numpy as np
import torch

from presp.evaluator import Evaluator
from presp.prescriptor import NNPrescriptor


class CircleEvaluator(Evaluator):
    def __init__(self, device: str = "cpu", n_jobs: int = 1):
        super().__init__(["f1", "f2"], n_jobs=n_jobs)
        self.device = device
        self.contexts = torch.tensor([[1.0], [2.0], [4.0]], dtype=torch.float32, device=device)
        self.test_set = torch.tensor([[0.5], [3.0], [5.0]], dtype=torch.float32, device=device)

    def update_predictor(self, _):
        pass

    def get_optimal_actions(self, test: bool = False) -> torch.Tensor:
        """
        Returns the optimal actions for each context.
        returns X: c x a x L where L is the number of points we want to use to plot.
        """
        X = []
        contexts = self.contexts if not test else self.test_set
        for c in contexts:
            c = c.item()
            x1 = torch.linspace(0, c, steps=1000, device=self.device)
            x2 = torch.sqrt(c**2 - x1**2)
            x = torch.stack([x1, x2], dim=0)
            X.append(x)

        X = torch.stack(X, dim=0)
        return X

    # pylint: disable=invalid-name
    def f1(self, X: torch.Tensor) -> float:
        """
        Minimize x1
        """
        return X[:, 0].unsqueeze(1)

    def f2(self, X: torch.Tensor) -> float:
        """
        Minimize x2
        """
        return X[:, 1].unsqueeze(1)

    def g1(self, X: torch.Tensor) -> torch.Tensor:
        """
        X: 3x2 -> 3x1
        Constraint that forces x1 and x2 to be outside of the circle radius c.
        x1^2 + x2^2 - c >= 0
        """
        return -1 * (torch.sum(X**2, dim=1).unsqueeze(1) - self.contexts**2)

    def g2(self, X: torch.Tensor) -> torch.Tensor:
        """
        Constraint forcing x1 to be greater than 0
        """
        return -1 * X[:, 0].unsqueeze(1)

    def g3(self, X: torch.Tensor) -> torch.Tensor:
        """
        Constraint forcing x2 to be greater than 0
        """
        return -1 * X[:, 1].unsqueeze(1)

    def prescribe(self, candidate: NNPrescriptor, test: bool = False) -> torch.Tensor:
        """
        Returns the solutions generated by the candidate prescriptor.
        """
        with torch.no_grad():
            X = candidate.forward(self.contexts) if not test else candidate.forward(self.test_set)
        return X

    def compute_outcomes(self, actions: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor]:
        """
        Computs individual outcomes for each set of actions.
        actions: c x a
        outcomes: c x o, c x g
        Where C is the number of contexts, a is the number of actions, o is the number of outcomes, and g is the number
        of constraints.
        """
        f1 = self.f1(actions)
        f2 = self.f2(actions)
        F = torch.cat([f1, f2], dim=1)

        g1 = self.g1(actions)
        g2 = self.g2(actions)
        g3 = self.g3(actions)
        G = torch.cat([g1, g2, g3], dim=1)

        return F, G

    def evaluate_candidate(self, candidate: NNPrescriptor) -> tuple[np.ndarray, float]:
        with torch.no_grad():
            actions = self.prescribe(candidate)
            F, G = self.compute_outcomes(actions)

            f = F.mean(dim=0).cpu().numpy()
            g = torch.where(G > 0, G, 0).sum(dim=1).mean().item()

        return f, g
